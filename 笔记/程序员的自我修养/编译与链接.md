---
typora-root-url: 图
---





### 3 目标文件

#### 3.1 目标文件的格式

现代PC流行的可执行程序分为两种：

1. windows下的.exe(PE-COFF)

2. linux下的 ELF

都是源于COFF文件。

| ELF文件类型                            | 说明                                                         | 实例                                               |
| -------------------------------------- | :----------------------------------------------------------- | -------------------------------------------------- |
| 可重定位文件<br />（Relocatable File） | 这类文件包含了代码和数据，可以用来被链接成可执行文件或者共享目标文件，静态链接库也可以归为这一类 | Linux 的.0<br />Windows的.obj                      |
| 可执行程序<br />（Executable FIle）    | 这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，一般没有扩展名 | 比如/bin/bash文件<br />Windows的.exe               |
| 共享库文件<br />(Shared Objct File)    | 这类文件包含了代码和数据，可以在以下两种情况下使用。<br />一种是链接器可以使用这种文件跟其他的可重定位文件和共享目录文件链接，产生新的目标文件。<br />2.是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。(==遗留问题==) | Linux 的.so，如/lib/glibc-2.5.so<br />Windows的DLL |
| 核心转储文件<br />（Core Dump File）   | 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 | Linux下的code dump                                 |



#### 3.2 目标文件是怎么样的

```
目标文件的内容至少有编译过的机器指令代码、数据。除此之外还有一些链接时需要用到的信息，比如符号表、调试信息、字符串等等。
一般目标文件将这些信息按不同的属性，以段（节）的形式存储。 
```



| 段名                 | 内容                                                         |
| -------------------- | ------------------------------------------------------------ |
| File Header          | 文件头，它描述了整个文件的文件属性，包括段表、文件是否可以执行、是静态链接还是动态链接及入口地址、目标硬件、目标操作系统等等。段表：描述了文件中各个段在文件中的偏移量及段的属性等，从段表里可以得到每个段的所有信息。 |
| .text(.code) section | 编译后的机器指令代码                                         |
| .data section        | 初始化得全局变量与局部静态变量                               |
| .bss section         | 尚未初始化得全局变量与局部静态变量（没有数据，一般在文件中不占空间） |

总体来说，程序源代码编译后主要分为两种段：程序指令与程序数据。代码段属于指令，而数据段和.bss段属于程序数据。

为什么要分开？分开有哪些好处：

1. 当程序被装载后，数据分别被映射到两个虚拟内存区域（==？？==）。这两个虚拟区域的权限可以分别被设置成可读写和只读，防止程序指令被篡改。
2. 提高缓存的命中率。
3. 共享指令，节省内存。当系统运行多个该进程的副本时，由于指令是只读的，所以可以在内存中只保留一份（除此之外可能还有图标，图片，文本资源等），从而大量节省内存空间。

#### 3.3 挖掘SimpleSection.o

```c
#include<stdio.h>
int printf(const char* format, ...);
int global_init_var = 84;
int global_unint_var;

void func1(int i){
    printf("%d\n", i);
}

int main(void) {
    static int static_var = 85;
    static int static_var2;
    int a = 1;
    int b;
    
    func1(static_var + static_var2 + a +b);
    return 0;
}
```

* 编译为.o的目标文件：gcc -c SimpleSection.c

* 使用objdump命令查看目标文件的结构和内容

   objdump -h SimpleSection.o

![image-20201220205217000](/image-20201220205217000.png)

* 查看段大小

  size SimpleSection.o

  ![image-20201220205426617](/image-20201220205426617.png)

##### 3.3.1 代码段

​	objdump的-s参数可以将所有段内容以16进制的方式打印出来， -d参数可以将所有包含指令的段反汇编。

<img src="/image-20201220210038220.png" alt="image-20201220210038220" style="zoom: 80%;" />

<img src="/image-20201220205943803.png" alt="image-20201220205943803" style="zoom:80%;" />

-s可见.text段的长度是59个字节刚好与-h显示的长度相等，-h反汇编显示push %rbp指令所占用是55与-s显示开始字节相同，并且main函数最后的c3 retq也与-s显示的结尾字节相同。

##### 3.3.2 数据段与只读数据段

* .data 是存放初始化的全局变量和局部静态变量，在代码中定义了一个全局变量global_int_var与static_var两个int变量刚好8个字节。这一结果与-h显示.data段中的size吻合。

* .rodata是存放只读变量（const修饰）与字符串常量。同理在装载程序是可以映射为只读区域方式被更改。
* objdump -x -s -d SimpleSection.o

![image-20201220213409609](/image-20201220213409609.png)

![image-20201220213432875](/image-20201220213432875.png)

##### 3.3.3 BSS段

bss段存放未初始化全局变量和局部静态变量，代码中我们定了未初始化的global_unint_var与static_var2两个int类型变量。理论上应该是占8个字节，但在上图显示占4个字节。通过符号表查看，实际上是只有static_var2被放入了.bss段，而global_unint_var没有被放入任何段，只是一个未定义的“COMMON”符号。

##### 3.3.4 其他段

| 常用的段名       | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| .rodata1         | Read Only Data,这种段里存放只读数据，比如字符串常量、全局const变量。跟.rodata一样 |
| .comment         | 存放的是编译器版本信息，比如字符串：“GCC:(GNU)4.2.0”         |
| .debug           | 调试信息                                                     |
| .dynamic         | 动态链接信息                                                 |
| .hash            | 符号哈希表                                                   |
| .line            | 调试时的行号表，即源代码行号与编译后指令的对应表             |
| .note            | 额外的编译器信息，比如程序的公司名、发布版本号等             |
| .strtab          | String Table字符串表，用于存储ELF文件中用到的各种字符串      |
| .symtab          | Symbol Table 符号表                                          |
| .shstrtab        | Section String Table 段名表                                  |
| .plt<br />.got   | 动态链接的跳转表和全局入口表                                 |
| .init<br />.fini | 程序初始化与终结代码段                                       |

我们可以在ELF文件中放入一些二进制文件，比如图片，MP3音乐等等，可以用objcopy工具。也会产生一些段，但是段名不会以.开头，防止与系统段重名。一个ELF文件结构中可以有重名的段名，比如两个.text段。

另外GCC编译器提供一个扩展功能，可以自定义段（自定义代码或者变量放入某个自定义的段中，用于完成一些特殊功能）。

#### 3.4 ELF文件结构描述

#### 3.5 链接的接口--符号

#### 3.6 调试信息

