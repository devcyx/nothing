---
typora-root-url: 图
---





### 3 目标文件

#### 3.1 目标文件的格式

现代PC流行的可执行程序分为两种：

1. windows下的.exe(PE-COFF)

2. linux下的 ELF

都是源于COFF文件。

| ELF文件类型                            | 说明                                                         | 实例                                               |
| -------------------------------------- | :----------------------------------------------------------- | -------------------------------------------------- |
| 可重定位文件<br />（Relocatable File） | 这类文件包含了代码和数据，可以用来被链接成可执行文件或者共享目标文件，静态链接库也可以归为这一类 | Linux 的.o<br />Windows的.obj                      |
| 可执行程序<br />（Executable FIle）    | 这类文件包含了可以直接执行的程序，它的代表就是ELF可执行文件，一般没有扩展名 | 比如/bin/bash文件<br />Windows的.exe               |
| 共享库文件<br />(Shared Objct File)    | 这类文件包含了代码和数据，可以在以下两种情况下使用。<br />一种是链接器可以使用这种文件跟其他的可重定位文件和共享目录文件链接，产生新的目标文件。<br />2.是动态链接器可以将几个这种共享目标文件与可执行文件结合，作为进程映像的一部分来运行。(==遗留问题==) | Linux 的.so，如/lib/glibc-2.5.so<br />Windows的DLL |
| 核心转储文件<br />（Core Dump File）   | 当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其他信息转储到核心转储文件 | Linux下的code dump                                 |



#### 3.2 目标文件是怎么样的

```
目标文件的内容至少有编译过的机器指令代码、数据。除此之外还有一些链接时需要用到的信息，比如符号表、调试信息、字符串等等。
一般目标文件将这些信息按不同的属性，以段（节）的形式存储。 
```



| 段名                 | 内容                                                         |
| -------------------- | ------------------------------------------------------------ |
| File Header          | 文件头，它描述了整个文件的文件属性，包括段表、文件是否可以执行、是静态链接还是动态链接及入口地址、目标硬件、目标操作系统等等。段表：描述了文件中各个段在文件中的偏移量及段的属性等，从段表里可以得到每个段的所有信息。 |
| .text(.code) section | 编译后的机器指令代码                                         |
| .data section        | 初始化得全局变量与局部静态变量                               |
| .bss section         | 尚未初始化得全局变量与局部静态变量（没有数据，一般在文件中不占空间） |

总体来说，程序源代码编译后主要分为两种段：程序指令与程序数据。代码段属于指令，而数据段和.bss段属于程序数据。

为什么要分开？分开有哪些好处：

1. 当程序被装载后，数据分别被映射到两个虚拟内存区域（==？？==）。这两个虚拟区域的权限可以分别被设置成可读写和只读，防止程序指令被篡改。
2. 提高缓存的命中率。
3. 共享指令，节省内存。当系统运行多个该进程的副本时，由于指令是只读的，所以可以在内存中只保留一份（除此之外可能还有图标，图片，文本资源等），从而大量节省内存空间。

#### 3.3 挖掘SimpleSection.o

```c
#include<stdio.h>
int printf(const char* format, ...);
int global_init_var = 84;
int global_unint_var;

void func1(int i){
    printf("%d\n", i);
}

int main(void) {
    static int static_var = 85;
    static int static_var2;
    int a = 1;
    int b;
    
    func1(static_var + static_var2 + a +b);
    return 0;
}
```

* 编译为.o的目标文件：gcc -c SimpleSection.c

* 使用objdump命令查看目标文件的结构和内容

   objdump -h SimpleSection.o

![image-20201220205217000](/image-20201220205217000.png)

* 查看段大小

  size SimpleSection.o

  ![image-20201220205426617](/image-20201220205426617.png)

##### 3.3.1 代码段

​	objdump的-s参数可以将所有段内容以16进制的方式打印出来， -d参数可以将所有包含指令的段反汇编。

<img src="/image-20201220210038220.png" alt="image-20201220210038220" style="zoom: 80%;" />

<img src="/image-20201220205943803.png" alt="image-20201220205943803" style="zoom:80%;" />

-s可见.text段的长度是59个字节刚好与-h显示的长度相等，-h反汇编显示push %rbp指令所占用是55与-s显示开始字节相同，并且main函数最后的c3 retq也与-s显示的结尾字节相同。

##### 3.3.2 数据段与只读数据段

* .data 是存放初始化的全局变量和局部静态变量，在代码中定义了一个全局变量global_int_var与static_var两个int变量刚好8个字节。这一结果与-h显示.data段中的size吻合。

* .rodata是存放只读变量（const修饰）与字符串常量。同理在装载程序是可以映射为只读区域方式被更改。
* objdump -x -s -d SimpleSection.o

![image-20201220213409609](/image-20201220213409609.png)

![image-20201220213432875](/image-20201220213432875.png)

##### 3.3.3 BSS段

bss段存放未初始化全局变量和局部静态变量，代码中我们定了未初始化的global_unint_var与static_var2两个int类型变量。理论上应该是占8个字节，但在上图显示占4个字节。通过符号表查看，实际上是只有static_var2被放入了.bss段，而global_unint_var没有被放入任何段，只是一个未定义的“COMMON”符号。

##### 3.3.4 其他段

| 常用的段名       | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| .rodata1         | Read Only Data,这种段里存放只读数据，比如字符串常量、全局const变量。跟.rodata一样 |
| .comment         | 存放的是编译器版本信息，比如字符串：“GCC:(GNU)4.2.0”         |
| .debug           | 调试信息                                                     |
| .dynamic         | 动态链接信息                                                 |
| .hash            | 符号哈希表                                                   |
| .line            | 调试时的行号表，即源代码行号与编译后指令的对应表             |
| .note            | 额外的编译器信息，比如程序的公司名、发布版本号等             |
| .strtab          | String Table字符串表，用于存储ELF文件中用到的各种字符串      |
| .symtab          | Symbol Table 符号表                                          |
| .shstrtab        | Section String Table 段名表                                  |
| .plt<br />.got   | 动态链接的跳转表和全局入口表                                 |
| .init<br />.fini | 程序初始化与终结代码段                                       |

我们可以在ELF文件中放入一些二进制文件，比如图片，MP3音乐等等，可以用objcopy工具。也会产生一些段，但是段名不会以.开头，防止与系统段重名。一个ELF文件结构中可以有重名的段名，比如两个.text段。

另外GCC编译器提供一个扩展功能，可以自定义段（自定义代码或者变量放入某个自定义的段中，用于完成一些特殊功能）。

#### 3.4 ELF文件结构描述

##### 3.4.1 文件头

​	我们可以使用readelf -h SimpleSection.o来查看文件头

![image-20201221193236360](/image-20201221193236360.png)

ELF文件头结构相关常数被定义在/usr/include/elf.h文件里。下图为64位机器的文件头结构。

![image-20201223191855936](/image-20201223191855936.png)

我们将ELF头文件结构与readelf输出的头文件相比有很多都一一对应，除了前六个参数，见下图：

| 头文件结构成员 | readelf 输出的结果与含义                                     |
| -------------- | ------------------------------------------------------------ |
| e_ident        | Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br/>  Class:                             ELF64<br/>  Data:                              2's complement, little endian<br/>  Version:                         1 (current)<br/>  OS/ABI:                          UNIX - System V<br/>  ABI Version:                  0 |
| e_type         | Type:                              REL (Relocatable file)<br />ELF文件类型 |
| e_machine      | Machine:                           Advanced Micro Devices X86-64<br />ELF文件的CPU平台属性。相关常量以EM_开头。如上图可以在X86的机器上运行，不能arm上运行。 |
| e_version      | Version:                           0x1<br />ELF的版本号，一般为常数1. |
| e_entry        | Entry point address:               0x0<br />ELF程序的入口虚拟地址，指程序被装载后，从哪个地址开始执行指令。重定位文件一般没有入口地址，则这个值为0. |
| e_phoff        | Start of program headers:          0 (bytes into file)<br />参考“ELF链接视图和执行视图”一节 |
| e_shoff        | Start of section headers:          1112 (bytes into file)<br />段表在这个文件中的偏移量。本案例中，段表从1113这个字节开始的。 |
| e_flags        | Flags:                             0x0<br />ELF标志位，用来标识一些ELF文件平台的相关属性。相关常量的格式一般为EF_machine_flag,machine为平台，flag为标志 |
| e_ehsize       | Size of this header:               64 (bytes)<br />ELF头文件本身大小，该案例中为64个字节 |
| e_phentsize    | Size of program headers:           0 (bytes)<br />参考“ELF链接视图和执行视图”一节 |
| e_phnum        | Number of program headers:         0<br />参考“ELF链接视图和执行视图”一节 |
| e_shentsize    | Size of section headers:           64 (bytes)<br />段表描述符的大小 |
| e_shnum        | Number of section headers:         13<br />段表描述符的数量。这个值等于ELF文件中拥有的段的数量，该案例中为11. |
| e_shstrndx     | Section header string table index: 12<br />段表字符串表所在段表中的下标 |

* **ELF模数**

| 16进制   | 含义                                |
| -------- | ----------------------------------- |
| 7f       | ASCII字符中DEL控制符                |
| 45       | ASCII字符中E                        |
| 4c       | ASCII字符中L                        |
| 46       | ASCII字符中F                        |
| 02       | 01代表32位，02代表64位              |
| 01       | 字节序，规定该ELF文件是大端还是小端 |
| 01       | 主版本号，一般为1。                 |
| 00 ..... | 后面9个字节都为预留。               |

* **文件类型**

| 常量    | 值   | 含义                       |
| ------- | ---- | -------------------------- |
| ET_REL  | 1    | 可重定位文件，一般为.o文件 |
| ET_EXEC | 2    | 可执行文件                 |
| ET_DYN  | 3    | 共享目标文件               |

##### 3.4.2 段表

段表中记录各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。也就是说段结构是由段表决定的，编译器、链接器和装载器都是依靠段表来定位和访问各个段的属性的。objdump -h只显示比较重要的段。可以使用readelf -S来查看真正的段表结构。

![image-20201223201704683](/image-20201223201704683.png)

段表在elf.h中的定义

```c
typedef struct
{
  Elf64_Word    sh_name;                /* Section name (string tbl index) */
  Elf64_Word    sh_type;                /* Section type */
  Elf64_Xword   sh_flags;               /* Section flags */
  Elf64_Addr    sh_addr;                /* Section virtual addr at execution */
  Elf64_Off     sh_offset;              /* Section file offset */
  Elf64_Xword   sh_size;                /* Section size in bytes */
  Elf64_Word    sh_link;                /* Link to another section */
  Elf64_Word    sh_info;                /* Additional section information */
  Elf64_Xword   sh_addralign;           /* Section alignment */
  Elf64_Xword   sh_entsize;             /* Entry size if section holds table */
} Elf64_Shdr;

```

* **sh_name**

段名是个字符串，它位于.shstrtab的字符串表。sh_name是段名字符串在字符串表中的偏移量。

* **sh_type**

段的名字只是在链接和编译过程中有意义，不能真正的表示段的类型。而链接器与编译器来说决定段的属性是sh_type和sh_flags。

| 常量         | 值   | 含义                               |
| ------------ | ---- | ---------------------------------- |
| SHT_NULL     | 0    | 无效段                             |
| SHT_PROGBITS | 1    | 程序段。代码段、数据段都是这个类型 |
| SHT_SYMTAB   | 2    | 表示该段的内容为符号表             |
| SHT_STRTAB   | 3    | 表示该段的内容为字符串表           |
| SHT_RELA     | 4    | 重定位表。包含了重定位信息         |
| SHT_HASH     | 5    | 符号表的哈希表                     |
| SHT_DYNAMIC  | 6    | 动态链接信息                       |
| SHT_NOTE     | 7    | 提示性信息                         |
| SHT_NOBITS   | 8    | 表示该段在文件中没内容，比如.bss段 |
| SHT_REL      | 9    | 该段包含重定位信息                 |
| SHT_SHLIB    | 10   | 保留                               |
| SHT_DYNSYM   | 11   | 动态链接的符号表                   |

* **sh_flags**

段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写等。在elf.h中相关常量以SHF_开头。

| 常量          | 值   | 含义                                                         |
| ------------- | ---- | ------------------------------------------------------------ |
| SHF_WRITE     | 1    | 表示该段在进程空间中可写                                     |
| SHF_ALLOC     | 2    | 表示该段在进程空间中需要分配空间。有些包含指示或控制信息的段不需要在进程空间中被分配空间，他们一般不会有这个标志。像代码段、数据段和.bss段都会有这个标志位。 |
| SHF_EXECINSTR | 4    | 表示该段在进程空间中可以被执行，一般指代码段                 |

* **sh_addr**

段的虚拟地址。如果该段可以被加载，则sh_addr为该段被加载后在进程地址空间中的虚拟地址，否则为0。

* **sh_offset**

如果段存在于文件中，则表示该段在文件中的偏移量；

* **sh_size**

段的长度

* **sh_link和sh_info**

如果段的类型是与链接相关的，比如重定位表，符号表，则该信息有意义。

| sh_type     | sh_link                              | sh_info                            |
| ----------- | ------------------------------------ | ---------------------------------- |
| SHT_DYNAMIC | 该段所使用的字符串表在段表中的下标   | 0                                  |
| SHT_HASH    | 该段所使用的符号表在段表中的下标     | 0                                  |
| SHT_REL     | 该段所使用的相应符号表在段表中的下标 | 该重定位表所作用的段在段表中的下标 |
| SHT_RELA    | 该段所使用的相应符号表在段表中的下标 | 该重定位表所作用的段在段表中的下标 |
| SHT_SYMTAB  | 操作系统相关                         | 操作系统相关                       |
| SHT_DYNSYM  | 操作系统相关                         | 操作系统相关                       |
| other       | SHN_UNDEF                            | 0                                  |

* **sh_addralign**

段地址对齐。如果为0或1，则该段没有对齐要求

* **sh_entsize**

项的长度

##### 3.4.3 重定位表

sh_type类型为SHT_REL的，则该段指向重定位表。链接器在处理目标文件是，需要对目标文件中某些部位进行重定向，即代码段和数据段中那个对绝对地址的引用的位置。该案例中.rel.text段针对.text段的重定位表。因为.text段中至少有一个绝对地址的引用，就是printf函数。而数据段没有绝对地址的引用，只包含了几个常量，所以没有.rel.data。而sh_info指定作用于那个段，该案例中为1  而.text段下标刚好为1.

##### 3.4.4 字符串表

因为字符串的长度往往不是固定的，所以用固定的结构表示很困难。一般的做法是把字符串集中起来，放到一张表，然后使用字符串在表中的偏移来引用字符串。

在ELF文件中字符串表也以段的形式保存，常见的段名为.strtab（字符串表）和.shstrtab（段表字符串）。字符串表用来保存普通的字符串。段表字符串表用来保存段表中用到的字符串，比如说段名。

在文件头中记录了段表字符串表在段表中的下标，只有分析ELF头，才能解析段表字符串表的位置，然后解析整个ELF文件



#### 3.5 链接的接口--符号

在链接中，目标文件相互结合实际上是目标文件之间对地址的引用，即对函数和变量地址的引用。在链接中，我们将函数和变量统称为符号，函数名和变量名就是符号名。每一个符号都有一个对应的值，叫做符号值。对于变量和函数来说，符号值就是地址。

符号表中所有的符号进行分类，他们有可能是下面这些类型中的一种：

* 定义在本目标文件的全局符号，可以被其他目标文件引用。比如main func01 global_init_var
* 在本目标文件中引用的全局符号，却没有在本目标文件中定义，这一般叫做外部符号。比如printf
* 段名，这种符号往往由编译器产生，它的值就是该段的起始地址。
* 局部符号，这类符号只在编译单元内部可见。比如static_var
* 行号信息。

![image-20201223215008574](/image-20201223215008574.png)

##### 3.5.1 ELF符号表结构

```c
// 在elf.h文件中定义符号表结构
typedef struct
{
  Elf64_Word    st_name;                /* Symbol name (string tbl index) */
  unsigned char st_info;                /* Symbol type and binding */
  unsigned char st_other;               /* Symbol visibility */
  Elf64_Section st_shndx;               /* Section index */
  Elf64_Addr    st_value;               /* Symbol value */
  Elf64_Xword   st_size;                /* Symbol size */
} Elf64_Sym;

```

* **st_name**

符号名，这个成员包含了该符号名在字符串表中的下标

* **st_value**
  * 在目标文件，如果是符号的定义并且该符号不是COMMON块类型的，则表示改符号在段中的偏移量。
  * 在目标文件中,如果符号是COMMON块类型的，则表还该符号的对齐属性。
  * 在可执行文件，表示符号的虚拟地址。
* **st_size**

符号大小。对于包含数据的符号，这个值是该数据类型的大小。比如一个int类型就是4。如果为0，则表示该符号大小为0或者未知。

* **st_info**

该成员低4位表示符号类型，高28位表示符号绑定信息。

符号绑定信息

| 宏定义名   | 值   | 说明                             |
| ---------- | ---- | -------------------------------- |
| STB_LOCAL  | 0    | 局部符号，对于目标文件外部不可见 |
| STB_GLOBAL | 1    | 全局符号，外部可见               |
| STB_WEAK   | 2    | 弱引用符号类型                   |

符号类型

| 宏定义名    | 值   | 说明                                                   |
| ----------- | ---- | ------------------------------------------------------ |
| STT_NOTYPE  | 0    | 未知                                                   |
| STT_OBJECT  | 1    | 该符号是数据对象                                       |
| STT_FUNC    | 2    | 该符号是函数或者其他可执行代码                         |
| STT_SECTION | 3    | 该符号表示一个段，这种符号必须是STB_LOCAL的            |
| STT_FILE    | 4    | 该符号表示文件名，一般都是该目标文件所对应的源文件名。 |



* **st_other**

该成员目前为0，没啥用

* **st_shndx**

符号所在段

| 宏定义名   | 值     | 说明                                                         |
| ---------- | ------ | ------------------------------------------------------------ |
| SHN_ABS    | 0xfff1 | 表示改符号包含了一个绝对的值。比如文件名符号                 |
| SHN_COMMON | 0xfff2 | 表示该符号是一个COMMON块，一般来说未初始化的全局符号定义就是这种类型的 |
| SHN_UNDEF  | 0      | 表示该符号未定义。不在目标文件中定义，但是在目标文件中引用   |

##### 3.5.2 特殊符号

在链接中，链接器会定义一些特殊符号，我们可以在程序中直接申明并使用。比如：

* __executable_start，该符号为程序起始地址。
* __etext，该符号为代码段结束的地址
* 以上地址都为被程序装载时的虚拟地址

##### 3.5.3 符号修饰与函数签名

c++中的函数重用，就是将函数名和变量名根据一定的规则改名，使相同名称的函数根据参数不同而使用不同的函数。

* C语言，用GCC编译器改名通常都是名称前面加_  来进行函数签名。
* C++，用GCC编译器会根据命名空间、类、函数名、参数类型及其他信息来进行函数签名。

##### 3.5.4 extern "C"

在C++编译器中为了与C兼容，一般用extern “C” 来申明接下来的代码使用C的名称修饰。

如果在C++的代码中可以用 __cplusplus宏定义来判断是否加载这段代码。

##### 3.5.5 弱符号与强符号

在多个目标文件中包含相同名字的全局符号的定义，那么这些目标文件链接的时候将会出现符号重复定义的错误。这种符号定义可以被称为强符号，比如全局初始化的变量。有些符号的定义可以被称为弱符号，比如全局为初始化变量，或者\__attribute__((weak))定义的符号。

针对强弱符号的概念，链接器在链接的时候会按如下规则处理：

1. 不允许强符号被多次定义。否则链接器会报错。
2. 如果一个符号在某个目标文件里是强符号，在其他文件中都是弱符号，那么选择强符号。
3. 如果一个符号在所有目标文件里都是弱符号，那么选择其中占用空间最大的一个。

**弱引用和强引用**

如果连接器在链接时找不到该符号的定义，链接器会报符号未定义的错误，则这种引用被称为强引用。反之就是弱引用。

在GCC中，我们可以通过\__attribute__((weakref))这个扩展关键字来申明对一个外部函数的引用为弱引用。

弱引用的好处：

1. 实现重写的功能
2. 如果某天删除了代码，程序也不会崩溃
3. 可以在运行时动态判断，引用哪一个函数

#### 3.6 调试信息

一般我们在编译的时候加上-g 参数 编译器会加上调试信息。

![image-20201223225622114](/image-20201223225622114.png)

如上如所示，段表中新增了很多调试的段信息。在我们CI框架中，编译的过程中都是加入了-g参数。在打包的过程中会对包进行strip操作，去掉打印信息。